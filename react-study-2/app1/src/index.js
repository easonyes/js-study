import React from 'react';
import ReactDOM from 'react-dom';
import '../res/styles/main.css';
import PropTypes from 'prop-types';
// import * as serviceWorker from './serviceWorker';
// import TodoApp from "./TodoApp";
// import Timer from "./before/Timer";
// import MyComponent from "./ComponentLifeCycle";
// import UserGitHub from "./UserGitHub";

/*// class MyComponent extends React.Component {
//   render() {
//     return (
//       <h2>我的老婆赖小七</h2>
//     );
//   }
// }
// const MyComponent = () => (
//   <h2>我的老婆赖小七~~~</h2>
// );

// const MyCom = function() {
//   return (
//     <h3>老婆老婆赖小七</h3>
//   );
// };

// class HelloMessage extends React.Component{
//   // 若是需要绑定 this.方法，或者是需要在 constructor 使用 props， 定义state
//   // 就要 constructor 。若是在其他方法（如 render ）使用 this.props 则不用一定要定义
//   constructor(props) {
//     // 对于 OOP 面向对象程序设计熟悉的读者应该对于 constructor 建构子的使用不陌生
//     // 事实上它是 ES6 的语法糖， 骨子里还是 prototype based 面向对象程序语言。
//     // 通过 extends 可以继承 React.Component 父类别。super 方法可以调用继承父类别的建构子
//     super(props);
//     this.state = {};
//   }
//   // render 是唯一必须的方法，但如果是单纯 render UI 建议使用 Functional Component 写法
//   // 性能较佳且简洁
//   render() {
//     return (
//       <div>Hello {this.props.name}</div>
//     );
//   }
// }

// Functional Component 可以视为 f(d) => UI, 根据传进去的 props 绘出相应的 UI。 注意
// 这边 props 是传入函数的参数，因此取用 props 不用加 this
// const HelloMessage = (props) => (
//   <div>Hello {props.name}</div>
// );
//
// // PropTypes 验证，若传入的 props type 不是 string 将会显示错误
// HelloMessage.propTypes = {
//   name: PropTypes.string,
// };
//
// // Prop 预设值，若对应 props 没传入值将会使用 default 值 Zuck
// HelloMessage.defaultProps = {
//   name: 'Zuck',
// };


// ReactDOM.render(<Timer />, document.getElementById('app'));

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://bit.ly/CRA-PWA
// serviceWorker.register();*/



